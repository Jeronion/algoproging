
Рекурсия — это приём программирования, при котором функция **вызывает саму себя** для решения подзадач, постепенно сводя их к более простым случаям. Идея простая: если задача может быть выражена через ту же задачу меньшего размера — рекурсия отлично подходит.

В Obsidian эта тема часто используется в заметках по алгоритмам, структурам данных и мышлению программиста.

---

## Базовая идея

Любая рекурсивная функция состоит из **двух обязательных частей**:

1. **Базовый случай** — условие, при котором рекурсия останавливается.
2. **Рекурсивный шаг** — вызов функции с более простой версией исходной задачи.

Без базового случая рекурсия уйдёт в бесконечный вызов и приведёт к переполнению стека.

---

## Простой пример

Задача: вычислить факториал числа `n`.

Определение:

* `0! = 1` — базовый случай
* `n! = n × (n - 1)!` — рекурсивный шаг

Псевдологика:

* если `n == 0` → вернуть `1`
* иначе → вернуть `n * factorial(n - 1)`

Каждый вызов ждёт результата следующего, пока не будет достигнут базовый случай.

---

## Как «думает» рекурсия

Рекурсию удобно представлять как **стек вызовов**:

* `factorial(3)` ждёт `factorial(2)`
* `factorial(2)` ждёт `factorial(1)`
* `factorial(1)` ждёт `factorial(0)`
* `factorial(0)` возвращает `1`

После этого значения начинают возвращаться обратно вверх по стеку.

---

## Когда рекурсия особенно полезна

Рекурсия хорошо подходит для задач, где структура данных или логика **самоподобны**:

* обход деревьев (DOM, AST, файловая система)
* графы
* алгоритмы «разделяй и властвуй»
* парсинг выражений
* генерация комбинаций и перестановок

Пример мышления:

> Чтобы решить задачу целиком, нужно решить её же, но для меньшей части.

---

## Рекурсия vs итерация

**Плюсы рекурсии:**

* код короче и выразительнее
* ближе к математическому описанию
* легче читать для сложных структур

**Минусы рекурсии:**

* расходует стек вызовов
* может быть медленнее
* риск переполнения стека

Во многих случаях рекурсию можно переписать через цикл, но ценой читаемости.

---

## Хвостовая рекурсия

Хвостовая рекурсия — это форма рекурсии, где рекурсивный вызов является **последней операцией** функции.

Некоторые языки и компиляторы умеют оптимизировать такие вызовы, превращая их в цикл и экономя память.

Важно: не все языки поддерживают оптимизацию хвостовой рекурсии.

---

## Частые ошибки

* ❌ отсутствие базового случая
* ❌ базовый случай никогда не достигается
* ❌ слишком глубокая рекурсия
* ❌ дублирующие вычисления (без мемоизации)

Полезный вопрос при отладке:

> Становится ли задача проще при каждом рекурсивном вызове?

---

## Мемоизация

Мемоизация — это сохранение результатов рекурсивных вызовов, чтобы не вычислять их повторно.

Особенно полезно для:

* чисел Фибоначчи
* динамического программирования
* экспоненциальных рекурсивных алгоритмов

---

## Краткое резюме

* Рекурсия — это функция, вызывающая саму себя
* Нужны базовый случай и рекурсивный шаг
* Отлично подходит для самоподобных задач
* Требует аккуратности и понимания стека

Рекурсия — не магия, а дисциплина мышления.
