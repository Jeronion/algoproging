## Logic Building — что это на самом деле

**Logic Building** — это умение _думать как алгоритм_, применять [[Алгоритмическое мышление]], а не писать код на конкретном языке. Язык — всего лишь инструмент. Если логика построена правильно, код можно написать на любом языке.

---

## Анализ задачи

Любая задача начинается не с кода, а с понимания условий. Здесь важно ответить себе на вопросы: _что у меня есть, что от меня хотят и какие есть ограничения_.

**Пример** 
Задача:

> Дан массив чисел. Найти максимальную сумму подмассива.

На этом этапе не нужно придумывать алгоритм. Нужно понять:

- массив может быть пустым?
    
- могут ли быть отрицательные числа?
    
- какого размера массив (10 элементов или 10⁶)?
    
- нужно вернуть сумму или сам подмассив?
    

Если не задать эти вопросы, можно написать красивый, но неправильный алгоритм. Например, решение, которое работает только с положительными числами, сразу сломается на массиве `[-2, -3, -1]`.

Хорошая логика начинается с **правильных вопросов**.

---

## Разбиение на шаги

Большинство задач кажутся сложными, потому что мы пытаемся решить их целиком. Логическое мышление требует _декомпозиции_ — разложения задачи на простые шаги.

**Пример**  
Задача:

> Проверить, является ли строка палиндромом.

Вместо «как проверить палиндром?» логика выглядит так:

1. Сравнить первый и последний символ
    
2. Потом второй и предпоследний
    
3. Продолжать, пока не дойдём до середины
    
4. Если все пары совпали — это палиндром
    

Каждый шаг прост. Сложность исчезает, когда задача разбита.

---

## Поиск закономерностей и паттернов

Большинство алгоритмических задач — это **вариации типовых решений**, а не что-то уникальное. Logic Building — это умение узнать знакомый паттерн.

**Пример**  
Задачи вида:

- «найти подотрезок»
    
- «максимальная/минимальная сумма»
    
- «подпоследовательность»
    

Часто сводятся к паттернам:

- два указателя
    
- скользящее окно
    
- префиксные суммы
    
- динамическое программирование
    

Например, задача «максимальная сумма подмассива» — это не новая задача, а вариация **Kadane’s Algorithm**. Тот, кто узнаёт паттерн, решает задачу за минуты. Тот, кто не знает — пытается перебрать всё.

---
## Учёт граничных случаев

Почти все ошибки в алгоритмах возникают не в основном сценарии, а **на границах**.

**Пример**  
Задача: найти максимум в массиве.

Работает для `[1, 2, 3]`, но что если:

- массив пуст?
    
- массив из одного элемента?
    
- все элементы отрицательные?
    
- все элементы одинаковые?
    

Алгоритм, который не учитывает границы, — логически неполный. Хорошая логика всегда задаёт вопрос:  
**«А что если вход минимальный, максимальный или странный?»**