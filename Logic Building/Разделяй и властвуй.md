
# Алгоритм «Разделяй и властвуй» (Divide and Conquer)


Алгоритм **«Разделяй и властвуй»** — это стратегия решения задач, которая включает три основных шага:

1. **Разделение (Divide)**: Разбиваем задачу на меньшие непересекающиеся подзадачи.

2. **Преодоление (Conquer)**: Решаем каждую из меньших задач.

3. **Объединение (Combine)**: Используем решения меньших задач, чтобы получить решение исходной задачи.


Примеры алгоритмов, использующих подход «Разделяй и властвуй»: **Merge Sort, Quick Sort, Binary Search, Closest Pair of Points**.

- В некоторых алгоритмах нет необходимости в явном шаге объединения, например, в **Binary Search** и **Quick Sort**. В то же время в **Merge Sort** шаг объединения является ключевым.
    
- Шаг разделения может быть простым, например, в **Merge Sort** и **Binary Search** мы просто делим массив пополам. Однако в **Quick Sort** этот шаг более сложный.
    

Следующее изображение показывает работу алгоритма «Разделяй и властвуй» для сортировки массива с использованием **Merge Sort**:

_(здесь можно вставить схему работы Merge Sort)_

**Преимущества алгоритма «Разделяй и властвуй»**:

- Простота рекурсивной реализации
- Эффективность для больших задач
- Хорошо подходит для параллельных вычислений

**Недостатки**:

- Может потреблять больше памяти, чем итеративные методы
- Не всегда эффективен для небольших задач

**Заключение**:  
Алгоритмы «Разделяй и властвуй» являются фундаментальными в информатике. Они лежат в основе многих известных алгоритмов сортировки и поиска, обеспечивая эффективное и элегантное решение сложных задач.

---
## Асимптотическая сложность

Для алгоритмов **разделяй и властвуй** (Divide and Conquer) рекуррентные соотношения часто имеют вид:

$$
T(n) = aT(n/b) + f(n)
$$

Где:

* $a$ — количество подзадач
* $n/b$ — размер каждой подзадачи
* $f(n)$ — работа вне рекурсивных вызовов (деление и объединение)

В таких случаях для **асимптотического анализа** удобно использовать [[Теорема Мастера]], которая позволяет быстро определить рост функции $T(n)$ без построения полного дерева рекурсии.

**Кратко:**

* Если $f(n)$ растёт медленнее, чем рекурсия на подзадачах → $T(n) = Θ(n^{\log_b a})
* Если $f(n)$ растёт как подзадачи → $T(n) = Θ(n^{\log_b a} \log n)$
* Если $f(n)$ растёт быстрее → $T(n) = Θ(f(n))$