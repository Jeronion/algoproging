Битовые операторы — это специальные операторы в программировании, которые работают непосредственно с бинарными битами (0 и 1). Так как компьютер хранит все данные в двоичной форме, битовые операции позволяют манипулировать данными на самом низком уровне, используя операции AND, OR, XOR, NOT и сдвиги битов.

* Используются в оптимизации, критически важных для производительности задачах, маскировании и переключении битов.
* Позволяют выполнять быстрые вычисления и бинарные манипуляции.
* Помогают устанавливать, сбрасывать, проверять и переключать биты.
* Часто быстрее для низкоуровневых и битовых операций.
* Позволяют упаковывать несколько флагов в одну переменную, экономя память.

---

## Битовые операторы / Основы работы с битами

Битовые операции работают с бинарными битами (0 и 1) с помощью битовых операторов, что делает их быстрыми и эффективными. Эти операции выполняются арифметико-логическим устройством (ALU) процессора и часто применяются для оптимизации, управления флагами и задач, критичных к производительности.

Основные битовые операторы:

* AND (`&`)
* OR (`|`)
* XOR (`^`)
* NOT (`~`)
* Левый сдвиг (`<<`)
* Правый сдвиг (`>>`)

---

### Битовый оператор AND (`&`)

Оператор AND обозначается символом `&`. Он принимает два двоичных числа одинаковой длины и сравнивает их биты. Если оба бита равны 1, результат будет 1, иначе 0.

**Пример:**

```python
a = 7   # 111 в двоичном виде
b = 4   # 100 в двоичном виде

result = a & b
print(result)
```

**Вывод:**

```
4
```

---

### Битовый оператор OR (`|`)

Оператор OR обозначается символом `|`. Если хотя бы один из сравниваемых битов равен 1, результат будет 1. Если оба бита 0 — результат 0.

**Пример:**

```python
a = 12  # 1100
b = 25  # 11001

result = a | b
print(result)
```

**Вывод:**

```
29
```

---

### Битовый оператор XOR (`^`)

Оператор XOR (`^`) — это "исключающее ИЛИ". Если сравниваемые биты различны, результат равен 1, если одинаковы — 0.

**Пример:**

```python
a = 12  # 1100
b = 25  # 11001

result = a ^ b
print(result)
```

**Вывод:**

```
21
```

---

### Битовый оператор NOT (`~`)

Оператор NOT (`~`) требует только один операнд и возвращает **дополнение до единицы** (инвертирует все биты).

**Пример:**

```python
a = 0

print("Исходное значение:", a)
print("Инверсия с использованием ~:", ~a)
print("Инверсия без знакового бита:", int(not a))
```

**Вывод:**

```
Исходное значение: 0
Инверсия с использованием ~: -1
Инверсия без знакового бита: 1
```

---

### Левый сдвиг (`<<`)

Оператор `<<` сдвигает биты влево на указанное количество позиций, заполняя освободившиеся справа нулями. Каждый сдвиг на 1 бит умножает число на 2.

**Пример:**

```python
num = 5

print(num << 1)  # 10
print(num << 2)  # 20
print(num << 3)  # 40
```

---

### Правый сдвиг (`>>`)

Оператор `>>` сдвигает биты вправо. Для положительных чисел освободившиеся позиции заполняются нулями, для отрицательных — единицами. Каждый сдвиг на 1 бит делит число на 2.

**Пример:**

```python
num = 5

print(num >> 1)  # 2
print(num >> 2)  # 1
print(num >> 3)  # 0
```

---

## Применение битовых операторов

* Оптимизация встроенных систем.
* Проверка целостности файлов с использованием XOR.
* Шифрование и сжатие данных.
* Сетевые протоколы и формирование пакетов.
* Обработка цифровых изображений и выделение фрагментов.

---

## Практические задачи

### 1. Установить бит на n-й позиции

```python
def set(num, pos):
    num |= (1 << pos)
    print(num)

num, pos = 4, 1
set(num, pos)  # Вывод: 6
```

### 2. Сбросить бит на n-й позиции

```python
def unset(num, pos):
    num &= ~(1 << pos)
    print(num)

num, pos = 7, 1
unset(num, pos)  # Вывод: 5
```

### 3. Переключить бит на n-й позиции

```python
def toggle(num, pos):
    num ^= (1 << pos)
    print(num)

num, pos = 4, 1
toggle(num, pos)  # Вывод: 6
```

### 4. Проверка бита на n-й позиции

```python
def at_position(num, pos):
    return num & (1 << pos)

num, pos = 5, 0
print(at_position(num, pos))  # Вывод: 1
```

### 5. Умножение числа на 2 через левый сдвиг

```python
num = 12
print(num << 1)  # Вывод: 24
```

### 6. Деление числа на 2 через правый сдвиг

```python
num = 12
print(num >> 1)  # Вывод: 6
```

### 7. XOR чисел от 1 до n

```python
def xor_1_to_n(n):
    x = n % 4
    if x == 0: return n
    if x == 1: return 1
    if x == 2: return n + 1
    return 0
```

### 8. Проверка числа на степень 2

```python
def isPowerOfTwo(x):
    return x != 0 and (x & (x - 1)) == 0

print(isPowerOfTwo(2))  # True
```

### 9. Подсчет установленных битов

```python
def countBits(n):
    count = 0
    while n:
        count += n & 1
        n >>= 1
    return count

print(countBits(5))  # 2
```

### 10. Позиция правого установленного бита

```python
def positionOfRightmostSetBit(n):
    if n == 0: return 0
    if n & 1: return 1
    n = n ^ (n & (n - 1))
    pos = 0
    while n:
        n >>= 1
        pos += 1
    return pos

n = 18
print(positionOfRightmostSetBit(n))  # 2
```

---

**Ссылки на дополнительные материалы:**

* Bits manipulation (Важные приёмы)
* Bitwise Hacks for Competitive Programming
* Bit Tricks for Competitive Programming
* Дополнительные задачи по битовым алгоритмам

---

Если хочешь, я могу сразу сделать для Obsidian **готовый `.md` файл с этим переводом**, с корректной разметкой кода и заголовков, чтобы можно было просто открыть и работать.

Хочешь, чтобы я это сделал?
