# AVL-дерево (Adelson-Velsky и Landis)

**AVL-дерево** — это самобалансирующееся бинарное дерево поиска (**BST**), в котором для любого узла разница высот левого и правого поддеревьев не превышает 1.

AVL — по фамилиям создателей: **Г. М. Адельсон-Вельский** и **Е. М. Ландис**.

---

## Фактор баланса

```text
Balance Factor = высота(левого поддерева) − высота(правого поддерева)
```

Для сбалансированного AVL-дерева:

```text
-1 ≤ Balance Factor ≤ 1
```

Если для какого-либо узла это условие нарушается, выполняются **повороты (rotations)** для восстановления баланса.

---

## Пример AVL-дерева

Если у всех узлов фактор баланса находится в диапазоне от −1 до +1, дерево является AVL-деревом.

Пример факторов баланса:

```
12 : +1  
8  : +1  
18 : +1  [[Перечисление бинарных деревьев]]
5  : +1  
11 : 0  
17 : 0  
4  : 0
```

Поскольку все значения лежат в пределах [-1, 1], дерево сбалансировано.

---

## Пример BST, который НЕ является AVL-деревом

Если хотя бы у одного узла:

```text
|Balance Factor| > 1
```

то дерево перестаёт быть AVL.

Например, если у узлов 8 и 12 фактор баланса больше 1 по модулю — дерево не является AVL.

---

# Важные моменты об AVL-дереве

### 1. Повороты (Rotations)

Повороты выполняются за **O(1)** и позволяют сохранять общую сложность операций **O(log n)**.

Существует 4 типа ребалансировки:

- LL (Left-Left)
    
- RR (Right-Right)
    
- LR (Left-Right)
    
- RL (Right-Left)
    

---

### 2. Вставка и удаление

- **Вставка** — выполняется как в обычном BST, затем при подъёме к корню проверяется баланс и при необходимости делаются повороты.
    
- **Удаление** — сложнее вставки, так как может потребоваться несколько ребалансировок.
    

В отличие от Red-Black Tree, AVL-дерево может выполнять больше поворотов при удалении.

---

### 3. Области применения

AVL-деревья подходят, когда:

- Требуются частые операции поиска
    
- Важна предсказуемая сложность
    
- Нужен отсортированный обход
    
- Используются операции floor / ceil / min / max

---

### 4. Сравнение с Red-Black Tree

AVL-деревья:

- быстрее при поиске (меньшая высота)
    
- но дороже при вставке и удалении
    

Поэтому в стандартных библиотеках чаще используется Red-Black Tree:

- `map` и `set` в C++
    
- `TreeMap` и `TreeSet` в Java
    

---

### 5. In-order обход

Как и любое BST:

```text
In-order traversal → элементы в отсортированном порядке
```

---

# Операции над AVL-деревом

## 1. Поиск (Search)

Выполняется так же, как в обычном BST.

Сложность:

```text
O(log n)
```

---

## 2. Вставка (Insertion)

1. Выполняется стандартная вставка BST.
    
2. Поднимаемся вверх по дереву.
    
3. Обновляем высоты.
    
4. Если нарушен баланс → выполняем поворот.
    

---

## 3. Удаление (Deletion)

1. Выполняется стандартное удаление BST.
    
2. Проверяется баланс на пути вверх.
    
3. При необходимости выполняются повороты.
    

Удаление может потребовать нескольких поворотов.

---

# Типы поворотов в AVL-дереве

AVL-дерево использует 4 случая.

---

## 1️⃣ Left-Left (LL)

### Когда возникает:

Узел вставляется в **левое поддерево левого ребёнка**.

Balance Factor становится > +1.

### Решение:

**Один правый поворот (Right Rotation)**

---

## 2️⃣ Right-Right (RR)

### Когда возникает:

Узел вставляется в **правое поддерево правого ребёнка**.

Balance Factor становится < -1.

### Решение:

**Один левый поворот (Left Rotation)**

---

## 3️⃣ Left-Right (LR)

### Когда возникает:

Узел вставляется в **правое поддерево левого ребёнка**.

Родитель становится перегруженным влево.

### Решение:

1. Левый поворот у левого ребёнка
    
2. Правый поворот у проблемного узла
    

---

## 4️⃣ Right-Left (RL)

### Когда возникает:

Узел вставляется в **левое поддерево правого ребёнка**.

Родитель становится перегруженным вправо.

### Решение:

1. Правый поворот у правого ребёнка
    
2. Левый поворот у проблемного узла
    

---

# Применение AVL-дерева

- Используется в обучении как первое самобалансирующееся BST (проще, чем Red-Black Tree).
    
- Подходит для систем с частыми операциями поиска.
    
- Используется в задачах с отсортированными данными.
    
- Подходит для real-time систем с предсказуемой производительностью.
    

---

# Преимущества AVL-дерева

- Самобалансируется автоматически
    
- Все операции выполняются за `O(log n)`
    
- Меньшая высота по сравнению с Red-Black
    
- Быстрее поиск
    
- Более строгая балансировка
    
- Проще для понимания, чем Red-Black
    

---

# Недостатки AVL-дерева

- Сложнее обычного BST
    
- Требует больше поворотов
    
- Реже используется в стандартных библиотеках
    
- Более строгие правила балансировки увеличивают накладные расходы
    

---

# Связанные темы

- Вставка в AVL-дерево
    
- Удаление из AVL-дерева
    
- Red-Black Tree
    

---

# Итог

AVL-дерево — это:

- Самобалансирующееся BST
    
- Гарантированная сложность `O(log n)`
    
- Более быстрый поиск по сравнению с Red-Black
    
- Чуть более дорогие вставка и удаление
    

Идеально подходит, когда **поиск выполняется чаще, чем модификации структуры**.