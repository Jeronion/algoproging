# Деревья (Tree Data Structure)

Дерево — это иерархическая структура данных, используемая для организации и представления информации в виде отношений «родитель — потомок».  
Дерево состоит из узлов, где верхний узел называется **корнем**, а каждый другой узел может иметь одного или нескольких **детей**.

---

## Основные термины

- **Родительский узел (Parent Node):** Узел, который является непосредственным предком другого узла.  
    _Пример:_ 35 — родитель 3 и 6.
    
- **Дочерний узел (Child Node):** Узел, который является непосредственным потомком другого узла.  
    _Пример:_ 3 и 6 — дети 35.
    
- **Корневой узел (Root Node):** Верхний узел дерева, не имеющий родителя.  
    _Пример:_ 15 — корень дерева.
    
- **Листовой узел (Leaf / External Node):** Узел, не имеющий детей.  
    _Пример:_ 1, 10, 12, 5, 7 — листовые узлы.
    
- **Предок (Ancestor):** Любой узел на пути от корня к данному узлу (исключая сам узел).  
    _Пример:_ 15 и 35 — предки 10.
    
- **Потомок (Descendant):** Узел x является потомком узла y, если y — предок x.  
    _Пример:_ 1, 10, 6 — потомки 35.
    
- **Сосед (Sibling):** Узлы, имеющие одного родителя.  
    _Пример:_ 1 и 10 — соседи; 5 и 7 — соседи.
    
- **Уровень узла (Level):** Количество рёбер от корня до данного узла. Корень находится на уровне 0.
    
- **Внутренний узел (Internal Node):** Узел, имеющий хотя бы одного ребёнка.
    
- **Сосед узла (Neighbor):** Родитель или дети узла.
    
- **Поддерево (Subtree):** Узел и все его потомки образуют поддерево.

---

## Почему дерево считается нелинейной структурой?

Данные в дереве **не хранятся последовательно**. Они организованы на нескольких уровнях, формируя **иерархическую структуру**.  
По этой причине дерево классифицируется как **нелинейная структура данных**.

---

## Представление узла

Дерево можно представить с помощью коллекции узлов. Каждый узел может быть представлен через класс или структуру.

```python
# Структура узла дерева
class Node:
    def __init__(self, x):
        self.data = x
        self.children = []
```

---

## Важность деревьев

- Деревья полезны для хранения данных, которые естественно образуют иерархию.
    
- Файловые системы компьютеров устроены в виде деревьев, где папки содержат подкаталоги и файлы.
    
- DOM (Document Object Model) HTML-страницы — это дерево:  
    `<html>` — корень, `<head>` и `<body>` — его дети. Эти теги могут иметь свои дочерние узлы.
    
- Деревья обеспечивают эффективную организацию и поиск данных в иерархических структурах.

---

## Типы деревьев

### [[Бинарное дерево поиска (BST)]]

Каждый узел может иметь **максимум двух детей**.

- **Полное бинарное дерево (Full Binary Tree):** каждый узел имеет 0 или 2 детей.
    
- **Завершённое бинарное дерево (Complete Binary Tree):** все уровни полностью заполнены, кроме последнего, который заполняется слева направо.
    
- **Сбалансированное бинарное дерево (Balanced Binary Tree):** разница высот между левым и правым поддеревом минимальна.

### Тернарное дерево (Ternary Tree)

Каждый узел может иметь **до трёх детей** (левая, средняя, правая ветви).

### N-арное дерево (N-ary / Generic Tree)

- Каждый узел может иметь **любое количество детей**.
    
- Узел содержит: данные + список ссылок на детей (дубликаты не допускаются).
    
- В отличие от связанных списков, узлы хранят ссылки на несколько детей.

---

## Основные операции

- **Создание (Create):** создание дерева.
    
- **Вставка (Insert):** добавление данных в дерево.
    
- **Поиск (Search):** проверка наличия определённого узла.
    
- **Обход (Traversal):**
    
    - **DFS (Depth-First Search)** — поиск в глубину
        
    - **BFS (Breadth-First Search)** — поиск в ширину
        

---

## Пример реализации на Python

```python
# Структура узла дерева
class Node:
    def __init__(self, x):
        self.data = x
        self.children = []

# Добавление дочернего узла
def addChild(parent, child):
    parent.children.append(child)

# Вывод родителей каждого узла
def printParents(node, parent):
    if parent is None:
        print(str(node.data) + " -> NULL")
    else:
        print(str(node.data) + " -> " + str(parent.data))
    for child in node.children:
        printParents(child, node)

# Вывод дочерних узлов
def printChildren(node):
    children_str = " ".join(str(child.data) for child in node.children)
    print(str(node.data) + " -> " + children_str)
    for child in node.children:
        printChildren(child)

# Вывод листовых узлов
def printLeafNodes(node):
    if not node.children:
        print(node.data, end=" ")
        return
    for child in node.children:
        printLeafNodes(child)

# Вывод степени каждого узла
def printDegrees(node, parent):
    degree = len(node.children)
    if parent is not None:
        degree += 1
    print(str(node.data) + " -> " + str(degree))
    for child in node.children:
        printDegrees(child, node)

# Пример использования
if __name__ == "__main__":
    root = Node(1)
    n2 = Node(2)
    n3 = Node(3)
    n4 = Node(4)
    n5 = Node(5)

    addChild(root, n2)
    addChild(root, n3)
    addChild(n2, n4)
    addChild(n2, n5)

    print("Родители узлов:")
    printParents(root, None)

    print("\nДети узлов:")
    printChildren(root)

    print("\nЛистовые узлы:")
    printLeafNodes(root)
    print("\n")

    print("Степени узлов:")
    printDegrees(root, None)
```

**Пример вывода:**

```
Родители узлов:
1 -> NULL
2 -> 1
4 -> 2
5 -> 2
3 -> 1

Дети узлов:
1 -> 2 3
2 -> 4 5
4 -> 
5 -> 
3 -> 

Листовые узлы:
4 5 3

Степени узлов:
1 -> 2
2 -> 3
4 -> 1
5 -> 1
3 -> 1
```

---

## Свойства дерева

- **Количество рёбер:** Дерево с N узлами имеет N − 1 рёбер. Существует **только один путь** между любыми двумя узлами.
    
- **Глубина узла (Depth):** Количество рёбер от корня до узла.
    
- **Высота дерева (Height):** Длина самого длинного пути от корня до листа.
    
- **Степень узла (Degree):** Количество поддеревьев (детей) узла.
    
    - Листовой узел имеет степень 0.
        
    - Степень дерева — максимальная степень среди всех узлов.

