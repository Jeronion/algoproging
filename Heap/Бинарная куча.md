# Ğ‘Ğ¸Ğ½Ğ°Ñ€Ğ½Ğ°Ñ ĞºÑƒÑ‡Ğ° (Binary Heap)

**Ğ‘Ğ¸Ğ½Ğ°Ñ€Ğ½Ğ°Ñ ĞºÑƒÑ‡Ğ°** â€” ÑÑ‚Ğ¾ Ğ¾ÑĞ¾Ğ±Ñ‹Ğ¹ Ğ²Ğ¸Ğ´ *Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ğ³Ğ¾ Ğ±Ğ¸Ğ½Ğ°Ñ€Ğ½Ğ¾Ğ³Ğ¾ Ğ´ĞµÑ€ĞµĞ²Ğ°* (Complete Binary Tree), Ğ² ĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğ¼:

* Ğ’ÑĞµ ÑƒÑ€Ğ¾Ğ²Ğ½Ğ¸ Ğ¿Ğ¾Ğ»Ğ½Ğ¾ÑÑ‚ÑŒÑ Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ñ‹,
* ĞŸĞ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğ¹ ÑƒÑ€Ğ¾Ğ²ĞµĞ½ÑŒ Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ÑĞµÑ‚ÑÑ ÑĞ»ĞµĞ²Ğ° Ğ½Ğ°Ğ¿Ñ€Ğ°Ğ²Ğ¾.

Ğ‘Ğ¸Ğ½Ğ°Ñ€Ğ½Ğ°Ñ ĞºÑƒÑ‡Ğ° Ğ¾Ğ±ĞµÑĞ¿ĞµÑ‡Ğ¸Ğ²Ğ°ĞµÑ‚ Ğ±Ñ‹ÑÑ‚Ñ€Ñ‹Ğ¹ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ Ğº Ğ¼Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğ¼Ñƒ Ğ¸Ğ»Ğ¸ Ğ¼Ğ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğ¼Ñƒ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ñƒ.

Ğ¡ÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚ Ğ´Ğ²Ğ° Ñ‚Ğ¸Ğ¿Ğ° ĞºÑƒÑ‡:

### ğŸ”¹ Min Heap (ĞœĞ¸Ğ½Ğ¸-ĞºÑƒÑ‡Ğ°)

* Ğ—Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ Ğ² ĞºĞ¾Ñ€Ğ½Ğµ â€” **Ğ¼Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ**.
* Ğ­Ñ‚Ğ¾ ÑĞ²Ğ¾Ğ¹ÑÑ‚Ğ²Ğ¾ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ÑĞµÑ‚ÑÑ Ğ´Ğ»Ñ Ğ²ÑĞµÑ… Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€ĞµĞ²ÑŒĞµĞ².

### ğŸ”¹ Max Heap (ĞœĞ°ĞºÑ-ĞºÑƒÑ‡Ğ°)

* Ğ—Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ Ğ² ĞºĞ¾Ñ€Ğ½Ğµ â€” **Ğ¼Ğ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ**.
* Ğ­Ñ‚Ğ¾ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»Ğ¾ Ñ‚Ğ°ĞºĞ¶Ğµ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ÑĞµÑ‚ÑÑ Ğ´Ğ»Ñ Ğ²ÑĞµÑ… Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€ĞµĞ²ÑŒĞµĞ².

Ğ‘Ğ¸Ğ½Ğ°Ñ€Ğ½Ñ‹Ğµ ĞºÑƒÑ‡Ğ¸ ÑˆĞ¸Ñ€Ğ¾ĞºĞ¾ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒÑÑ‚ÑÑ Ğ²:

* Ğ¾Ñ‡ĞµÑ€ĞµĞ´ÑÑ… Ñ Ğ¿Ñ€Ğ¸Ğ¾Ñ€Ğ¸Ñ‚ĞµÑ‚Ğ¾Ğ¼ (Priority Queue),
* Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼Ğµ Ğ¿Ğ¸Ñ€Ğ°Ğ¼Ğ¸Ğ´Ğ°Ğ»ÑŒĞ½Ğ¾Ğ¹ ÑĞ¾Ñ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²ĞºĞ¸ (Heap Sort),
* Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼Ğ°Ñ… Ğ½Ğ° Ğ³Ñ€Ğ°Ñ„Ğ°Ñ….

---

## ĞŸÑ€ĞµĞ´ÑÑ‚Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ±Ğ¸Ğ½Ğ°Ñ€Ğ½Ğ¾Ğ¹ ĞºÑƒÑ‡Ğ¸

Ğ¢Ğ°Ğº ĞºĞ°Ğº Ğ±Ğ¸Ğ½Ğ°Ñ€Ğ½Ğ°Ñ ĞºÑƒÑ‡Ğ° â€” ÑÑ‚Ğ¾ **Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ğµ Ğ±Ğ¸Ğ½Ğ°Ñ€Ğ½Ğ¾Ğµ Ğ´ĞµÑ€ĞµĞ²Ğ¾**, ĞµÑ‘ ÑƒĞ´Ğ¾Ğ±Ğ½Ğ¾ Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ Ğ² Ğ²Ğ¸Ğ´Ğµ Ğ¼Ğ°ÑÑĞ¸Ğ²Ğ°.

### Ğ˜Ğ½Ğ´ĞµĞºÑĞ°Ñ†Ğ¸Ñ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ²

ĞŸÑƒÑÑ‚ÑŒ Ñ‚ĞµĞºÑƒÑ‰Ğ¸Ğ¹ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚ Ğ¸Ğ¼ĞµĞµÑ‚ Ğ¸Ğ½Ğ´ĞµĞºÑ `i`.

| ĞĞ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ       | Ğ¤Ğ¾Ñ€Ğ¼ÑƒĞ»Ğ°        |
| -------------- | -------------- |
| Ğ Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒ       | `(i - 1) // 2` |
| Ğ›ĞµĞ²Ñ‹Ğ¹ Ğ¿Ğ¾Ñ‚Ğ¾Ğ¼Ğ¾Ğº  | `2 * i + 1`    |
| ĞŸÑ€Ğ°Ğ²Ñ‹Ğ¹ Ğ¿Ğ¾Ñ‚Ğ¾Ğ¼Ğ¾Ğº | `2 * i + 2`    |

* ĞšĞ¾Ñ€ĞµĞ½ÑŒ Ğ²ÑĞµĞ³Ğ´Ğ° Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑÑ Ğ² `arr[0]`.
* ĞŸÑ€ĞµĞ´ÑÑ‚Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ´Ğ¾ÑÑ‚Ğ¸Ğ³Ğ°ĞµÑ‚ÑÑ Ñ Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰ÑŒÑ **Ğ¾Ğ±Ñ…Ğ¾Ğ´Ğ° Ğ² ÑˆĞ¸Ñ€Ğ¸Ğ½Ñƒ (Level Order Traversal)**.

---

## ĞÑĞ½Ğ¾Ğ²Ğ½Ñ‹Ğµ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ Ñ ĞºÑƒÑ‡ĞµĞ¹

ĞÑĞ½Ğ¾Ğ²Ğ½Ñ‹Ğµ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ÑÑÑ‚ÑÑ Ğ·Ğ° **O(log n)**:

* `insert` â€” Ğ²ÑÑ‚Ğ°Ğ²ĞºĞ° ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ°
* `extract_min` / `extract_max` â€” ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ ĞºĞ¾Ñ€Ğ½Ñ
* `decrease_key` â€” ÑƒĞ¼ĞµĞ½ÑŒÑˆĞµĞ½Ğ¸Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ
* `delete_key` â€” ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ°
* `heapify` â€” Ğ²Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ ÑĞ²Ğ¾Ğ¹ÑÑ‚Ğ²Ğ° ĞºÑƒÑ‡Ğ¸

---

## Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Min Heap Ğ½Ğ° Python

```python
from __future__ import print_function
import math

class MinHeap:

    def __init__(self):
        self.arr = []

    def left(self, i): 
        return 2 * i + 1

    def right(self, i): 
        return 2 * i + 2

    def parent(self, i): 
        return (i - 1) // 2

    def get_min(self):
        return self.arr[0] if self.arr else None

    def insert(self, k):
        self.arr.append(k)
        i = len(self.arr) - 1

        while i > 0 and self.arr[self.parent(i)] > self.arr[i]:
            p = self.parent(i)
            self.arr[i], self.arr[p] = self.arr[p], self.arr[i]
            i = p

    def decrease_key(self, i, new_val):
        self.arr[i] = new_val

        while i != 0 and self.arr[self.parent(i)] > self.arr[i]:
            p = self.parent(i)
            self.arr[i], self.arr[p] = self.arr[p], self.arr[i]
            i = p

    def extract_min(self):
        if len(self.arr) <= 0: 
            return None
        if len(self.arr) == 1: 
            return self.arr.pop()

        res = self.arr[0]
        self.arr[0] = self.arr.pop()
        self.min_heapify(0)
        return res

    def delete_key(self, i):
        self.decrease_key(i, -float('inf'))
        self.extract_min()

    def min_heapify(self, i):
        l = self.left(i)
        r = self.right(i)
        n = len(self.arr)

        smallest = i

        if l < n and self.arr[l] < self.arr[smallest]:
            smallest = l
        if r < n and self.arr[r] < self.arr[smallest]:
            smallest = r

        if smallest != i:
            self.arr[i], self.arr[smallest] = self.arr[smallest], self.arr[i]
            self.min_heapify(smallest)
```

---

## ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ

```python
h = MinHeap()

h.insert(3)
h.insert(2)
h.delete_key(1)
h.insert(15)
h.insert(5)
h.insert(4)
h.insert(45)

print(h.extract_min(), end=" ")
print(h.get_min(), end=" ")

h.decrease_key(2, 1)
print(h.extract_min())
```

### Ğ’Ñ‹Ğ²Ğ¾Ğ´

```
2 4 1
```

---

## ĞŸÑ€Ğ¸Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğµ Ğ±Ğ¸Ğ½Ğ°Ñ€Ğ½Ñ‹Ñ… ĞºÑƒÑ‡

### ĞŸĞ¸Ñ€Ğ°Ğ¼Ğ¸Ğ´Ğ°Ğ»ÑŒĞ½Ğ°Ñ ÑĞ¾Ñ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²ĞºĞ° (Heap Sort)

ĞŸĞ¾Ğ·Ğ²Ğ¾Ğ»ÑĞµÑ‚ Ğ¾Ñ‚ÑĞ¾Ñ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¼Ğ°ÑÑĞ¸Ğ² Ğ·Ğ° **O(n log n)**.

### ĞÑ‡ĞµÑ€ĞµĞ´ÑŒ Ñ Ğ¿Ñ€Ğ¸Ğ¾Ñ€Ğ¸Ñ‚ĞµÑ‚Ğ¾Ğ¼ (Priority Queue)

ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ¸Ğ²Ğ°ĞµÑ‚:

* `insert`
* `extractMin / extractMax`
* `decreaseKey`
* `delete`

Ğ’ÑĞµ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ÑÑÑ‚ÑÑ Ğ·Ğ° **O(log n)**.

Ğ¡ÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‚ Ğ±Ğ¾Ğ»ĞµĞµ Ğ¿Ñ€Ğ¾Ğ´Ğ²Ğ¸Ğ½ÑƒÑ‚Ñ‹Ğµ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñ‹:

* Ğ‘Ğ¸Ğ½Ğ¾Ğ¼Ğ¸Ğ°Ğ»ÑŒĞ½Ğ°Ñ ĞºÑƒÑ‡Ğ°
* Ğ¤Ğ¸Ğ±Ğ¾Ğ½Ğ°Ñ‡Ñ‡Ğ¸ĞµĞ²Ğ° ĞºÑƒÑ‡Ğ°

### ĞĞ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼Ñ‹ Ğ½Ğ° Ğ³Ñ€Ğ°Ñ„Ğ°Ñ…

Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒÑÑ‚ÑÑ Ğ²:

* Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼Ğµ Ğ”ĞµĞ¹ĞºÑÑ‚Ñ€Ñ‹
* Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼Ğµ ĞŸÑ€Ğ¸Ğ¼Ğ°

### Ğ§Ğ°ÑÑ‚Ñ‹Ğµ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸

* ĞŸĞ¾Ğ¸ÑĞº k-Ğ³Ğ¾ Ğ½Ğ°Ğ¸Ğ±Ğ¾Ğ»ÑŒÑˆĞµĞ³Ğ¾ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ°
* Ğ¡Ğ¾Ñ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²ĞºĞ° Ğ¿Ğ¾Ñ‡Ñ‚Ğ¸ Ğ¾Ñ‚ÑĞ¾Ñ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾Ğ³Ğ¾ Ğ¼Ğ°ÑÑĞ¸Ğ²Ğ°
* Ğ¡Ğ»Ğ¸ÑĞ½Ğ¸Ğµ K Ğ¾Ñ‚ÑĞ¾Ñ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¼Ğ°ÑÑĞ¸Ğ²Ğ¾Ğ²

---

## ĞšÑ€Ğ°Ñ‚ĞºĞ¾Ğµ Ñ€ĞµĞ·ÑĞ¼Ğµ

Ğ‘Ğ¸Ğ½Ğ°Ñ€Ğ½Ğ°Ñ ĞºÑƒÑ‡Ğ° â€” ÑÑ‚Ğ¾:

* ĞŸĞ¾Ğ»Ğ½Ğ¾Ğµ Ğ±Ğ¸Ğ½Ğ°Ñ€Ğ½Ğ¾Ğµ Ğ´ĞµÑ€ĞµĞ²Ğ¾
* Ğ­Ñ„Ñ„ĞµĞºÑ‚Ğ¸Ğ²Ğ½Ğ°Ñ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¸Ğ¾Ñ€Ğ¸Ñ‚ĞµÑ‚Ğ½Ñ‹Ñ… Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¹
* ĞÑĞ½Ğ¾Ğ²Ğ° Ğ´Ğ»Ñ Heap Sort Ğ¸ Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼Ğ¾Ğ² Ğ½Ğ° Ğ³Ñ€Ğ°Ñ„Ğ°Ñ…
* Ğ ĞµĞ°Ğ»Ğ¸Ğ·ÑƒĞµÑ‚ÑÑ Ñ‡ĞµÑ€ĞµĞ· Ğ¼Ğ°ÑÑĞ¸Ğ²
* Ğ Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚ Ğ·Ğ° O(log n) Ğ´Ğ»Ñ Ğ¾ÑĞ½Ğ¾Ğ²Ğ½Ñ‹Ñ… Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¹