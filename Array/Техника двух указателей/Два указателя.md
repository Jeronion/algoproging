# Два указателя

Техника **двух указателей** — это простая, но мощная стратегия, при которой используются два индекса (указателя), проходящие по структуре данных — массиву, списку или строке — либо навстречу друг другу, либо в одном направлении, чтобы решать задачи более эффективно.

---

## Когда использовать технику двух указателей

### Отсортированный ввод

Если массив или список уже отсортирован (или его можно отсортировать), два указателя позволяют эффективно находить пары или диапазоны.  
**Пример:** найти два числа в отсортированном массиве, сумма которых равна заданному значению.

### Пары или подмассивы

Когда задача касается двух элементов, подмассивов или диапазонов, а не одиночных элементов.  
**Примеры:**

- самая длинная подстрока без повторяющихся символов
- максимальное количество подряд идущих единиц
- проверка, является ли строка палиндромом

### Задачи со скользящим окном (Sliding Window)

Когда необходимо поддерживать окно элементов, которое расширяется или сужается в зависимости от условий.  
**Примеры:**

- найти наименьший подмассив с суммой ≥ K
- переместить все нули в конец массива, сохранив порядок элементов

### Связанные списки (медленный–быстрый указатели)

Используется для обнаружения циклов, поиска середины списка или проверки палиндрома.  
**Пример:** алгоритм обнаружения цикла Флойда (Черепаха и Заяц).

---

## Наивный метод — O(n²) по времени и O(1) по памяти

Самый базовый подход — сгенерировать все возможные пары и проверить, равна ли их сумма целевому значению.  
Для этого используются два вложенных цикла.

```python
# Функция для проверки существования пары
# с суммой, равной target

def two_sum(arr, target):
    n = len(arr)

    # Проходим по каждому элементу массива
    for i in range(n):

        # Для каждого arr[i] проверяем все элементы
        # arr[j], идущие после него
        for j in range(i + 1, n):

            # Проверяем, равна ли сумма пары target
            if arr[i] + arr[j] == target:
                return True

    # Если подходящая пара не найдена
    return False


arr = [0, -1, 2, -3, 1]
target = -2

# Вызов функции
if two_sum(arr, target):
    print("true")
else:
    print("false")
```

---

## Техника двух указателей — O(n) по времени и O(1) по памяти

Идея метода — начать с двух концов массива.  
Используются два индекса: `left` и `right`.

### Алгоритм

1. Инициализация:

    - `left = 0`
    - `right = n - 1`

2. Пока `left < right`:
    
    - вычислить `sum = arr[left] + arr[right]`
    - если `sum == target` → пара найдена
    - если `sum < target` → увеличить `left`
    - если `sum > target` → уменьшить `right`

---

### Реализация

```python
# Функция для проверки существования пары
# с суммой, равной target

def two_sum(arr, target):

    left, right = 0, len(arr) - 1

    # Пока левый указатель меньше правого
    while left < right:
        sum = arr[left] + arr[right]

        # Проверяем сумму
        if sum == target:
            return True
        elif sum < target:
            left += 1   # Увеличиваем сумму
        else:
            right -= 1  # Уменьшаем сумму

    # Если пара не найдена
    return False
```

### Анализ сложности

- **Временная сложность:** $O(n)$ 
    Цикл выполняется не более `n` раз — на каждом шаге мы либо увеличиваем `left`, либо уменьшаем `right`.

- **Дополнительная память:** $O(1)$

---

### Случай 1: увеличиваем `left`

Это происходит, когда  
`arr[left] + arr[right] < target`.

Мы безопасно игнорируем `arr[left]`, потому что:

- с текущим `right` сумма слишком мала
- с любыми элементами левее `right` сумма будет ещё меньше
- элементы правее `right` уже были исключены ранее

Следовательно, `arr[left]` не может участвовать в решении.

---

### Случай 2: уменьшаем `right`

Аналогичная логика:

- если сумма слишком большая, `arr[right]` не может образовать нужную пару
- уменьшение `right` безопасно и не приводит к пропуску решения


---

## Частные случаи

Частные случаи данного алгоритма это:
- [[Бинарный поиск]]
- [[Скользящее окно]]

---

## Заключение

Техника двух указателей — это универсальный приём, который позволяет значительно упростить решение многих задач и сократить их асимптотическую сложность. Вместо перебора всех возможных вариантов мы используем свойства входных данных (упорядоченность, непрерывность диапазонов, линейный проход), чтобы **систематически исключать невозможные решения**.

Главное преимущество подхода — баланс между эффективностью и простотой: алгоритмы с двумя указателями легко реализуются, хорошо читаются и при этом работают за линейное время и константную память. Именно поэтому этот приём так часто встречается в задачах на собеседованиях и в реальном коде.

Важно помнить, что техника двух указателей не является «волшебной кнопкой» — она применима не всегда. Однако если задача связана с парами элементов, подмассивами, диапазонами или связными структурами данных, **проверка возможности применения двух указателей должна быть одним из первых шагов при проектировании решения**.

Освоив этот приём и понимая, _почему_ он работает, а не просто _как_, вы получаете мощный инструмент для написания быстрых, лаконичных и надёжных алгоритмов.