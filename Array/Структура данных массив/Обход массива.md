Конечно! Вот перевод текста про **обход массива** на русский язык:

---

# Обход массива

Последнее обновление: 19 февраля 2025 г.

**Обход массива** — это процесс последовательного доступа к каждому элементу массива, обычно для выполнения какой-либо операции, например поиска, сортировки или изменения элементов.

Обход массива необходим для широкого круга задач в программировании. Наиболее распространённые методы обхода включают использование циклов `for`, `while` или `foreach`. Эффективный обход играет ключевую роль в алгоритмах, которые требуют сканирования или обработки данных.

---

## Примеры:

```text
Вход: arr[] = [10, 20, 30, 40, 50]
Выход: 10 20 30 40 50
Объяснение: просто обходим массив и выводим числа.
```

```text
Вход: arr[] = [7, 8, 9, 1, 2]
Выход: 7 8 9 1 2
Объяснение: просто обходим массив и выводим числа.
```

```text
Вход: arr[] = [100, 200, 300, 400, 500]
Выход: 100 200 300 400 500
Объяснение: просто обходим массив и выводим числа.
```

---

## Виды обхода массива

### 1. Линейный обход

Линейный обход — это процесс посещения каждого элемента массива последовательно, начиная с первого и заканчивая последним. При этом каждый элемент обрабатывается (выводится, изменяется или проверяется) по порядку, в котором он хранится в массиве. Это самый простой и распространённый способ доступа к элементам массива.

**Пример на Python:**

```python
arr = [1, 2, 3, 4, 5]

print("Линейный обход: ", end=" ")
for i in arr:
    print(i, end=" ")
print()
```

**Вывод:**

```
Линейный обход: 1 2 3 4 5
```

**Сложность:**

* Время: O(n)
* Доп. память: O(1)

---

### 2. Обратный обход

Обратный обход — это процесс посещения каждого элемента массива, начиная с последнего и двигаясь к первому. Этот метод полезен, когда необходимо обработать элементы в обратном порядке.

**Пример на Python:**

```python
arr = [1, 2, 3, 4, 5]

print("Обратный обход: ", end="")
for i in range(len(arr)-1, -1, -1):
    print(arr[i], end=" ")
print()
```

**Вывод:**

```
Обратный обход: 5 4 3 2 1
```

**Сложность:**

* Время: O(n)
* Доп. память: O(1)

---

## Методы обхода массива

### 1. С помощью цикла `for`

Цикл `for` позволяет итерироваться по массиву, задавая начальный индекс, условие продолжения и шаг изменения индекса. Это самый распространённый и эффективный способ, когда известно количество элементов или требуется доступ по индексу.

```python
arr = [10, 20, 30, 40, 50]

print("Обход с помощью for: ", end='')
for i in arr:
    print(i, end=' ')
print()
```

**Вывод:** `10 20 30 40 50`
**Сложность:** O(n), Доп. память: O(1)

---

### 2. С помощью цикла `while`

Цикл `while` выполняется, пока заданное условие истинно. Контроль индекса осуществляется вручную, а не автоматически, как в цикле `for`. Полезно, если количество итераций заранее неизвестно.

```python
arr = [10, 20, 30, 40, 50]
n = len(arr)
i = 0

print("Обход с помощью while: ", end=" ")
while i < n:
    print(arr[i], end=" ")
    i += 1
print()
```

**Вывод:** `10 20 30 40 50`
**Сложность:** O(n), Доп. память: O(1)

---

## Применения обхода массива

Обход массива важен для всех операций, где требуется доступ к элементам. Наиболее распространённые применения: **поиск** и **изменение элементов**.

### 1. Поиск элемента

Обход массива используется для поиска элемента. Посещая каждый элемент по порядку, мы сравниваем его с искомым значением.

```python
arr = [10, 20, 30, 40, 50]
target = 30
found = False

# Линейный поиск с помощью обхода
for i in range(len(arr)):
    if arr[i] == target:
        found = True
        break

if found:
    print("Элемент найден!")
else:
    print("Элемент не найден!")
```

**Вывод:** `Элемент найден!`
**Сложность:** O(n), Доп. память: O(1)

---

### 2. Изменение элементов

Обход массива используется для изменения элементов, например, увеличения значений, умножения на константу или других операций.

```python
arr = [10, 20, 30, 40, 50]

# Увеличиваем каждый элемент на 5
for i in range(len(arr)):
    arr[i] += 5

# Вывод изменённого массива
print("Изменённый массив: ", end=' ')
for num in arr:
    print(num, end=' ')
print()
```

**Вывод:** `15 25 35 45 55`
**Сложность:** O(n), Доп. память: O(1)