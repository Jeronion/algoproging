# Бинарный поиск

## 1. Бинарный поиск в упорядоченных массивах

Под **упорядоченным массивом** будем понимать массив, упорядоченный по неубыванию, то есть: $a[1] ≤ a[2] ≤ … ≤ a[N]$

Пусть требуется найти элемент $x$ в таком массиве.  
Алгоритм **бинарного поиска** работает следующим образом:

1. Задаётся область поиска с левой и правой границами.
2. Выбирается середина текущей области.
3. Значение в середине сравнивается с искомым элементом:
    - если $x$ меньше среднего элемента, поиск продолжается в левой половине;
    - если $x$ больше среднего элемента, поиск продолжается в правой половине;
    - если элементы равны — поиск завершён.

Корректность алгоритма основана на том, что массив упорядочен то есть,
если $x$ меньше среднего элемента, то он **не может находиться правее**, и наоборот.

#### Реализация

```python
left, right = 0, len(array) - 1

while left <= right:
    mid = (left + right) // 2

    if array[mid] < x:
        left = mid + 1
    elif array[mid] > x:
        right = mid - 1
    else:
        print(mid)
        break
else:
    print(-1)
```

### Асимптотическая сложность

На каждом шаге размер области поиска уменьшается в 2 раза, поэтому:

- **временная сложность:** $O(log (n))$
- **память:** $O(1)$

---

## 2. Бинарный поиск для монотонных функций

Бинарный поиск применим не только к массивам, но и к **монотонным функциям** — возрастающим или убывающим.

### Определение

Функция называется **возрастающей**, если:

$$
∀ x₁, x₂ : x₁ > x₂ ⇒ f(x₁) > f(x₂)
$$

Для монотонной функции можно исключать половину области поиска, так же как и в массиве.  
Если функция **не монотонна**, бинарный поиск применять нельзя — алгоритм может дать неверный результат.

### Пример: поиск кубического корня

Кубическим корнем числа $x$ называется такое число $y$, что $y³ = x$

**Задача:**  
Для заданного вещественного числа $x$ $(x ≥ 1)$ найти значение `∛x` с точностью не менее 5 знаков после запятой.
#### Идея решения

- нижняя граница поиска: `1`
- верхняя граница поиска: `x`

На каждом шаге:

- берём середину отрезка;
- сравниваем $mid^3$ с $x$;
- в зависимости от результата сужаем область поиска.

#### Реализация

```python
eps = 10 ** (-11)
x = 20

left, right = 1, x

while right - left > eps:
    mid = (left + right) / 2
    if mid ** 3 < x:
        left = mid
    else:
        right = mid

print(left)
```

Точность результата контролируется значением `eps`.

---

## 3. Бинарный поиск по ответу

В ряде задач требуется найти **некоторое число-ответ**, при этом:

- легко проверить, **подходит ли текущее значение**; 
- напрямую вычислить ответ сложно или невозможно.

В этом случае применяется **бинарный поиск по ответу**.

### Общая схема

1. Выбирается значение, заведомо **меньшее ответа**.
2. Выбирается значение, заведомо **большее ответа**.
3. Проверяется середина диапазона:
    - если условие выполняется — сдвигаем границу с одной стороны;
    - иначе — сдвигаем границу с другой стороны.

## Пример бинарного поиска по ответу (Задача №1923. Дипломы)

#### Условие задачи (кратко)

Дано:

- $n$ одинаковых прямоугольников размером $w × h$
- прямоугольники **нельзя поворачивать**
- они не должны пересекаться
- требуется разместить их на **квадратной доске**
- сторона доски должна быть **минимально возможной**

Необходимо найти минимальный размер стороны квадратной доски.

---

## Ключевая идея решения

Мы не знаем заранее, **какой именно размер доски минимален**, но можем:

- **проверить**, можно ли разместить все дипломы на доске со стороной `x`;
- если можно — попробовать меньший размер;
- если нельзя — увеличить размер.

Это типичный случай **бинарного поиска по ответу**.

### Проверка возможности размещения

Пусть сторона доски равна `x`.

**Сколько дипломов помещается?**

- по горизонтали: $x // w$
- по вертикали: $x // h$

Тогда общее количество размещаемых дипломов:

$$
(x // w) · (x // h)
$$

Если это значение **не меньше $n$, значит размер $x$ подходит.

### Границы бинарного поиска

- **Левая граница:**  
    Минимально возможная сторона — `max(w, h)`, иначе не поместится даже один диплом

- **Правая граница:**  
    Достаточно взять `max(w * n, h * n)` все дипломы в один ряд

#### Реализация

```python
w, h, n = map(int, input().split())

left = max(w, h)
right = max(w * n, h * n)

while left <= right:
    mid = (left + right) // 2

    if (mid // w) * (mid // h) >= n:
        right = mid - 1
    else:
        left = mid + 1

print(left)
```

---

## Почему это работает

- Функция проверки **монотонна**:
    - если доска размера `x` подходит,
    - то любая доска большего размера тоже подойдёт.

- Это гарантирует корректность бинарного поиска.
- Мы находим **минимальное** значение `x`, при котором размещение возможно.

---

## Асимптотический сложность

- **Время:**  $O(log(max(w·n, h·n)))$
- **Память:**  $O(1)$

Алгоритм эффективно работает даже при максимальных ограничениях $w, h, n ≤ 10⁹$.

---

## Заключение

Бинарный поиск — это универсальный алгоритм, применимый не только к поиску элементов в упорядоченных массивах, но и к гораздо более широкому классу задач. Его ключевым свойством является способность **экспоненциально сокращать область поиска**, что обеспечивает логарифмическую временную сложность.

Обобщение бинарного поиска на **монотонные функции** и задачи **поиска по ответу** делает этот метод особенно ценным при решении задач оптимизации, где прямое вычисление ответа затруднено или невозможно. В таких задачах достаточно уметь проверять корректность предполагаемого решения.

Пример с задачей «Дипломы» демонстрирует, как бинарный поиск по ответу позволяет эффективно находить минимальное допустимое значение, опираясь на монотонность проверочной функции. Благодаря этому подходу алгоритм остаётся быстрым и надёжным даже при очень больших входных данных.

Таким образом, бинарный поиск является одним из базовых инструментов алгоритмического мышления и должен рассматриваться как **первый выбор** при решении задач, сводящихся к поиску границы между допустимыми и недопустимыми решениями.