
Экспоненциальный поиск состоит из двух шагов:

1. Найти диапазон индексов, в котором может находиться элемент
2. Выполнить бинарный поиск в найденном диапазоне

### Как найти диапазон?

Идея заключается в следующем:

* Начать с подмассива размера 1
* Сравнить его последний элемент с $x$
* Затем попробовать размер 2, потом 4, 8 и так далее
* Удваивать размер, пока последний элемент подмассива не станет **больше или равен $x$**

Когда мы находим индекс $i$ (путём многократного удвоения), мы знаем, что элемент находится в диапазоне **от $i/2$ до $i$**.

Почему $i/2$?
Потому что на предыдущей итерации значение в массиве ещё не превышало $x$.

---

## Рекурсивная реализация

**Временная сложность:** $O(log n)$
**Пространственная сложность:** $O(log n)$

Мы начинаем с индекса $i = 1$ и удваиваем его, пока:

* $i$ меньше длины массива
* $arr[i] < x$

После этого выполняем бинарный поиск в диапазоне:
`[i/2, min(i, n-1)]`

---

### Реализация на Python (рекурсивный бинарный поиск)

```python
# Рекурсивная функция бинарного поиска
# Возвращает индекс x в массиве arr[l..r], если элемент найден,
# иначе возвращает -1
def binarySearch(arr, l, r, x):
    if r >= l:
        mid = l + (r - l) // 2
        # Если элемент найден в середине
        if arr[mid] == x:
            return mid
        # Если элемент меньше середины, ищем слева
        if arr[mid] > x:
            return binarySearch(arr, l, mid - 1, x)
        # Иначе ищем справа
        return binarySearch(arr, mid + 1, r, x)

    # Если элемент не найден
    return -1


# Возвращает позицию первого вхождения x
def exponentialSearch(arr, n, x):
    # Если x находится в первом элементе
    if arr[0] == x:
        return 0
    # Поиск диапазона путём удвоения
    i = 1
    while i < n and arr[i] <= x:
        i = i * 2
    # Бинарный поиск в найденном диапазоне
    return binarySearch(arr, i // 2, min(i, n - 1), x)
```
---

## Итеративная реализация

**Временная сложность:** $O(log (n))$
**Пространственная сложность:** $O(1)$

Здесь используется итеративный бинарный поиск с тем же подходом.

```python
def exponential_search(arr, x):
    n = len(arr)
    if n == 0:
        return -1

    # Поиск диапазона путём удвоения
    i = 1
    while i < n and arr[i] < x:
        i *= 2

    # Бинарный поиск в диапазоне [i/2, min(i, n-1)]
    left = i // 2
    right = min(i, n - 1)

    while left <= right:
        mid = (left + right) // 2

        if arr[mid] == x:
            return mid
        elif arr[mid] < x:
            left = mid + 1
        else:
            right = mid - 1

    return -1
```

---

## Применения экспоненциального поиска

* Экспоненциальный поиск особенно полезен для **неограниченных массивов**, где размер массива неизвестен или считается **бесконечным**
* Работает **быстрее бинарного поиска**, если искомый элемент находится **ближе к началу массива**