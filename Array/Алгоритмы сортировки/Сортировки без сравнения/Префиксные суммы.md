## Префиксные суммы (Prefix Sum)

Префиксные суммы — это один из базовых и самых важных приёмов в **algorithmic thinking** и **logic building**. Он позволяет эффективно обрабатывать запросы на сумму, диапазоны, баланс элементов и другие задачи за линейное или константное время после предварительной обработки.

### Формальное определение

Для массива `arr` длины `n` префиксный массив `prefixSum` определяется так:

```
prefixSum[i] = arr[0] + arr[1] + ... + arr[i]
```

Иногда используется вариант с дополнительным нулём в начале:

```
prefixSum[0] = 0
prefixSum[i] = arr[0] + ... + arr[i - 1]
```

Второй вариант особенно удобен для задач с диапазонами.

---

## Зачем нужны префиксные суммы

Без префиксных сумм:

- каждый запрос суммы диапазона → $O(n)$
- много запросов → медленно

С префиксными суммами:

- предобработка → $O(n)$
- каждый запрос → $O(1)$

**Мы обмениваем память на скорость.**

---

## Получение суммы подмассива

Если используем массив `pref`, где:

```
pref[i] = сумма элементов arr[0 .. i-1]
```

то сумма на отрезке `[l, r]` считается как:

```
sum(l, r) = pref[r + 1] - pref[l]
```

Это ключевая формула, на которой строится 80% задач с prefix sum.

---

## Где используется Prefix Sum

### 1. Поиск точки равновесия массива (Equilibrium Index)

**Задача:** найти индекс `i`, где сумма слева равна сумме справа.

```python
if prefix_sum[i - 1] == prefix_sum[N - 1] - prefix_sum[i]:
```

**Идея:**

- `prefix_sum[i - 1]` — сумма слева
- `prefix_sum[N - 1] - prefix_sum[i]` — сумма справа

Сложность: $O(n)$ 
Ключевая мысль: **разность префиксов**

---

### 2. Среднее значение на диапазоне (Range Mean Query)

```python
(pref[r + 1] - pref[l]) / (r - l + 1)
```

**Важно:**

- используется `pref` размером `N + 1`
- это защищает от выхода за границы и упрощает формулы

Очень популярно в:

- статистике
- анализе данных
- задачах с большим количеством запросов

---

### 3. Восстановление массива по префиксным суммам

```python
arr[i] = presum[i] - presum[i - 1]
```

**Идея:**  
Префиксная сумма — это накопление, значит исходный элемент — это разность соседних префиксов.

Это показывает, что prefix sum — **обратимая структура данных**.

---

### 4. Минимальный подмассив с суммой ≥ target

Задача с LeetCode решается комбинацией:

- prefix sum
- two pointers

```python
s = pref[right] - pref[left]
```

Здесь prefix sum позволяет:

- быстро считать сумму
- не пересчитывать элементы каждый раз

---

### 5. Произведение элементов, кроме текущего

Задача `Product of Array Except Self` использует:

- **префиксное произведение**
- **суффиксное произведение**

```python
output[i] = pref[i - 1] * suff[i + 1]
```

Это расширение идеи prefix sum:

- вместо суммы → произведение
- логика остаётся той же

---

### 6. Проверка подмассива с суммой, кратной `k`

```python
(pref[i] + nums[i]) % k
```

Здесь используется важный принцип:

> Если два префикса имеют одинаковый остаток по модулю `k`,  
> то их разность делится на `k`.

Ключевые техники:

- prefix sum + modulo
- hash map

---

### 7. Самый длинный подмассив с равным количеством 0 и 1

```python
pref[i] = pref[i - 1] + (1 if nums[i - 1] else -1)
```

**Трюк:**

- 0 → -1
- 1 → +1

Одинаковые значения префикса означают равный баланс.

Это уже **уровень логического мышления**, а не просто формулы.

---

## Когда стоит сразу думать о Prefix Sum

Если в задаче есть:

- «сумма на диапазоне»
- «много запросов»
- «баланс слева и справа»
- «подмассив»
- «накопление»

**Prefix Sum почти наверняка часть решения.**

---

## Заключение

Префиксные суммы — это фундаментальный алгоритмический приём, мост между простой арифметикой и сложными задачами, основа для sliding window, hash + prefix, DP