
**Последнее обновление: 29 сентября 2025**

**Сортировка подсчётом (Counting Sort)** — это алгоритм сортировки **без сравнений**. Он особенно эффективен, когда диапазон входных значений невелик по сравнению с количеством сортируемых элементов.

### Основная идея сортировки подсчётом

- Алгоритм подсчитывает количество вхождений каждого различного элемента входного массива и использует эту информацию, чтобы разместить элементы на правильных позициях в отсортированном массиве.
    
- Он хорошо работает, когда диапазон входных значений мал и сопоставим с размером массива.  
    Например, для входного массива `[1, 4, 0, 2, 1, 1]` размер массива равен 6, а диапазон значений — от 0 до 4.
    
- Если диапазон входных значений значительно больше `n log n`, где `n` — размер массива, то лучше использовать стандартные алгоритмы сортировки на основе сравнений, такие как сортировка слиянием (Merge Sort).
    

---

## Алгоритм сортировки подсчётом

1. Объявить массив подсчёта `cntArr[]` размером `max(arr[]) + 1` и инициализировать его нулями.
    
2. Пройти по входному массиву `arr[]` и использовать каждый элемент как индекс в `cntArr[]`, то есть выполнить `cntArr[arr[i]]++` для `0 ≤ i < N`.
    
3. Вычислить **префиксные суммы** для каждого индекса массива `cntArr[]`.
    
4. Создать массив `ans[]` размером `N`.
    
5. Пройти по массиву `arr[]` с конца и выполнить  
    `ans[cntArr[arr[i]] - 1] = arr[i]`,  
    затем уменьшить `cntArr[arr[i]]` на 1.
    

---

## Почему мы вычисляем префиксные суммы?

Можно просто подсчитать количество вхождений всех элементов и поочерёдно поместить их в выходной массив, однако префиксные суммы используются для обеспечения **стабильности** алгоритма.

Обратите внимание: после построения массива префиксных сумм `cntArr[]` мы проходим исходный массив **справа налево**, чтобы последнее вхождение элемента оказалось на своей последней корректной позиции в отсортированном массиве.

---

## Пример реализации на Python

```python
def count_sort(arr):
    if not arr:
        return []

    n = len(arr)
    maxval = max(arr)

    # создать и инициализировать cntArr
    cntArr = [0] * (maxval + 1)

    # подсчитать частоту каждого элемента
    for v in arr:
        cntArr[v] += 1

    # вычислить префиксные суммы
    for i in range(1, maxval + 1):
        cntArr[i] += cntArr[i - 1]

    # построить выходной массив
    ans = [0] * n

    # проход с конца для сохранения стабильности
    for i in range(n - 1, -1, -1):
        v = arr[i]
        ans[cntArr[v] - 1] = v
        cntArr[v] -= 1

    return ans

```

---

## Анализ сложности сортировки подсчётом

- **Временная сложность:** `O(N + M)` во всех случаях,  
    где `N` — размер входного массива,  
    `M` — размер массива подсчёта.
    
- **Дополнительная память:** `O(N + M)`,  
    где `N` — память для выходного массива,  
    `M` — память для массива подсчёта.
    

---

## Преимущества сортировки подсчётом

- Обычно работает быстрее всех алгоритмов сортировки на основе сравнений (например, Merge Sort и Quick Sort), если диапазон входных значений сопоставим с количеством элементов.
    
- **Стабильный алгоритм.**
    

---

## Недостатки сортировки подсчётом

- Не работает с дробными (вещественными) числами.
    
- Неэффективна, если диапазон сортируемых значений очень велик.
    
- Не является **in-place** алгоритмом, так как требует дополнительную память.
    

---

## Применения сортировки подсчётом

- Используется в задачах с ограниченным диапазоном значений:  
    сортировка студентов по оценкам, событий по времени, дней, месяцев, лет и т.д.
    
- Применяется как подалгоритм в **поразрядной сортировке (Radix Sort)**.
    
- Идея сортировки подсчётом используется в **блочной сортировке (Bucket Sort)**.