# Shell Sort (сортировка Шелла)

**Shell Sort** — алгоритм сортировки, который улучшает сортировку вставками, позволяя элементам массива перемещаться на большие расстояния.  
За счёт этого элементы быстрее приближаются к своим итоговым позициям.

Алгоритм предложен **Дональдом Шеллом (1959)**.

---

## Принцип работы

1. Выбирается шаг `gap` — расстояние между сравниваемыми элементами.
2. Массив разбивается на несколько подпоследовательностей.
3. Каждая подпоследовательность сортируется вставками.
4. Шаг уменьшается.
5. При `gap = 1` выполняется обычная сортировка вставками.

---

## Выбор шага (gap)

Классическая последовательность Шелла:

```text
gap = n // 2
gap = gap // 2
...
gap = 1
```

На практике используются и более эффективные варианты (Knuth, Sedgewick), но классический проще для понимания.

---

## Реализация

```python
def shell_sort(arr: list[int]) -> None:
    n = len(arr)
    gap = n // 2

    while gap > 0:
        for i in range(gap, n):
            temp = arr[i]
            j = i

            # сортировка вставками с шагом gap
            while j >= gap and arr[j - gap] > temp:
                arr[j] = arr[j - gap]
                j -= gap

            arr[j] = temp

        gap //= 2
```

---

## Асимптотическая сложность

- **Временная сложность:**
    
    - Лучший случай: $O(n \log n)$ — если массив уже отсортирован
    - Средний случай: зависит от выбора шагов
    - Худший случай: $O(n^2)$ — если массив отсортирован в обратном порядке

Худший случай возможен при неудачном выборе последовательности шагов.

- **Дополнительная память:** $O(1)$ — сортировка выполняется на месте, не требует дополнительной памяти

---

## Заключение

Данный алгоритм сортировки сочетает в себе простоту реализации и экономное использование памяти, работая с дополнительной сложностью всего $O(1)$. По производительности он превосходит пузырьковую сортировку и сортировку вставками, что делает его более практичным выбором для массивов среднего размера.

Тем не менее, алгоритм не является устойчивым и не имеет строго определённой асимптотики для всех вариантов выбора шагов, а на больших объёмах данных уступает более эффективным алгоритмам, таким как Quick Sort и Merge Sort.

Таким образом, этот метод остаётся хорошим инструментом для обучения, работы в условиях ограниченной памяти и сортировки частично упорядоченных массивов, однако для масштабных задач предпочтительнее использовать более производительные алгоритмы.