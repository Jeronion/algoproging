# Heap Sort (Пирамидальная сортировка)

Heap Sort — это алгоритм сортировки сравнением, основанный на структуре данных «бинарная куча» (Binary Heap).

Основные идеи:

* Это улучшенная версия сортировки выбором.
* Алгоритм многократно находит максимальный элемент.
* Благодаря бинарной куче получение максимума выполняется за O(log n).
* Процесс повторяется, пока массив полностью не отсортирован.
* Общая сложность алгоритма — O(n log n).

---

# Алгоритм Heap Sort

## Шаг 1. Представление массива как полного бинарного дерева

Для массива размера `n`:

* Корень находится по индексу `0`
* Левый ребёнок элемента `i` → `2i + 1`
* Правый ребёнок элемента `i` → `2i + 2`

Таким образом массив интерпретируется как полное бинарное дерево.

---

## Шаг 2. Построение Max Heap

Массив преобразуется в макс-кучу (Max Heap).
Это делается вызовом `heapify` для всех внутренних узлов, начиная с последнего:

```python
for i in range(n // 2 - 1, -1, -1):
    heapify(arr, n, i)
```

После этого максимальный элемент находится в корне (`arr[0]`).

---

## Шаг 3. Сортировка массива

1. Меняем местами корень (максимум) и последний элемент.
2. Уменьшаем размер кучи.
3. Восстанавливаем свойство кучи с помощью `heapify`.
4. Повторяем процесс.

Максимальные элементы постепенно перемещаются в конец массива.

---

# Реализация на Python

```python
# Восстановление свойства Max Heap
def heapify(arr, n, i):

    largest = i

    l = 2 * i + 1
    r = 2 * i + 2

    if l < n and arr[l] > arr[largest]:
        largest = l

    if r < n and arr[r] > arr[largest]:
        largest = r

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)


# Основная функция сортировки
def heapSort(arr):

    n = len(arr)

    # Построение Max Heap
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    # Извлечение элементов из кучи
    for i in range(n - 1, 0, -1):

        arr[0], arr[i] = arr[i], arr[0]

        heapify(arr, i, 0)


if __name__ == "__main__":

    arr = [9, 4, 3, 8, 10, 2, 5]

    heapSort(arr)

    print("Sorted array is")
    for i in range(len(arr)):
        print(arr[i], end=" ")
```

---

## Вывод

```
Sorted array is
2 3 4 5 8 9 10
```

---

# Сложность

| Тип                | Значение                |
| ------------------ | ----------------------- |
| Время              | O(n log n)              |
| Доп. память        | O(log n) из-за рекурсии |
| Итеративная версия | O(1)                    |

---

# Почему O(n log n)

* Построение кучи — O(n)
* Каждое извлечение — O(log n)
* Таких извлечений — n

Итого:
O(n) + O(n log n) = O(n log n)

---

# Важные особенности

* Алгоритм работает in-place (без дополнительного массива).
* Обычно нестабилен (порядок равных элементов может меняться).
* Обычно медленнее хорошо реализованного QuickSort из-за плохой локальности памяти.

---

# Преимущества

1. Гарантированная сложность O(n log n).
2. Минимальное использование памяти.
3. Простая структура, основанная на бинарной куче.

---

# Недостатки

1. Более высокие константы по сравнению с Merge Sort.
2. Нестабильность.
3. Практически часто медленнее QuickSort.

---

Если нужно, могу дополнительно разобрать:

* почему построение кучи выполняется за O(n);
* пошаговую работу heapify;
* сравнение с QuickSort;
* вариант без рекурсии.
