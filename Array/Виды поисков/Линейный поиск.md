
**Задача:**  
Дан массив `arr[]` из `n` целых чисел и число `x`. Нужно определить, присутствует ли элемент `x` в массиве. Если элемент найден, вернуть индекс **первого вхождения** `x`, иначе вернуть `-1`.

### Примеры:

```text
Вход: arr[] = [1, 2, 3, 4], x = 3
Выход: 2
Объяснение: Элемент 3 находится на индексе 2.
```

```text
Вход: arr[] = [10, 8, 30, 4, 5], x = 5
Выход: 4
Объяснение: Элемент 5 находится на индексе 4.
```

```text
Вход: arr[] = [10, 8, 30], x = 6
Выход: -1
Объяснение: Элемента 6 нет в массиве.
```

---

## Как работает линейный поиск

В **линейном поиске** мы последовательно проверяем каждый элемент массива. Если текущий элемент равен искомому значению, возвращаем его индекс. Если элемент не найден, возвращаем `-1`.

Линейный поиск также называется **последовательным поиском**.

**Пример:**  
Для массива `arr[] = {10, 50, 30, 70, 80, 20, 90, 40}` и ключа `key = 30`, алгоритм проверяет элементы по очереди, пока не найдёт ключ.

---

## Реализация на Python

```python
def search(arr, x):
    n = len(arr)
    
    # Проходим по массиву и ищем элемент x
    for i in range(n):
        if arr[i] == x:
            return i
    return -1

if __name__ == "__main__":
    arr = [2, 3, 4, 10, 40]
    x = 10

    result = search(arr, x)
    if result == -1:
        print("Элемент не найден в массиве")
    else:
        print("Элемент найден на индексе", result)
```

**Вывод:**

```
Элемент найден на индексе 3
```

---

## Временная и пространственная сложность линейного поиска

**Временная сложность:**

- **Лучший случай:** элемент находится на первом индексе → O(1)
    
- **Худший случай:** элемент находится на последнем индексе или отсутствует → O(N)
    
- **Средний случай:** O(N)
    

**Дополнительная память:** O(1) — используется только переменная для итерации.

---

## Применения линейного поиска

- **Неотсортированные массивы:** когда массив не отсортирован, линейный поиск — самый простой способ найти элемент.
    
- **Малые наборы данных:** эффективен на небольших массивах.
    
- **Поиск в связанных списках:** используется для поиска элементов в linked list, проверяя узлы п---о очереди.
    
- **Простая реализация:** легче реализовать и понять, чем бинарный или тернарный поиск.
	
- Поиск минимума и максимума: линейно пройтись по списку и найти наименьший элемент.
---

## Преимущества линейного поиска

- Работает с любым массивом, отсортированным или нет.
    
- Не требует дополнительной памяти.
    
- Отлично подходит для небольших наборов данных.
    

---

## Недостатки линейного поиска

- Временная сложность O(N) делает его медленным для больших массивов.
    
- Не подходит для больших массивов.
    

---

## Когда использовать линейный поиск

- Когда набор данных небольшой.
    
- Когда данные хранятся в **смежной памяти** и не отсортированы.
    

