
Сортировка вставками — простой алгоритм сортировки, который работает путём последовательной вставки каждого элемента неотсортированного списка на его правильное место в уже отсортированной части списка. Это похоже на сортировку игральных карт в руках:

- Разделяем карты на две группы: отсортированные и неотсортированные.
    
- Берём карту из неотсортированной группы и вставляем её в правильное место среди отсортированных.
    

**Принцип работы:**

1. Начинаем со второго элемента (первый элемент считается уже отсортированным).
    
2. Сравниваем второй элемент с первым и, если второй меньше, меняем их местами.
    
3. Переходим к третьему элементу, сравниваем его с первыми двумя и вставляем на правильное место.
    
4. Повторяем процесс, пока весь массив не будет отсортирован.
    

---

## Python-программа для реализации сортировки вставками

```python
def insertionSort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1

        # Сдвигаем элементы arr[0..i-1], что больше key, на одну позицию вперёд
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
```

---

## Иллюстрация работы

Массив: `arr = {23, 1, 10, 5, 2}`

- **Начало:**  
    Текущий элемент: `23`  
    Первый элемент считается отсортированным: `[23]`
    
- **Первый проход:**  
    Сравниваем `1` с `23`.  
    Так как `1 < 23`, вставляем `1` перед `23`.  
    Отсортированная часть: `[1, 23]`
    
- **Второй проход:**  
    Сравниваем `10` с `1` и `23`.  
    Вставляем `10` между `1` и `23`.  
    Отсортированная часть: `[1, 10, 23]`
    
- **Третий проход:**  
    Сравниваем `5` с `1, 10, 23`.  
    Вставляем `5` между `1` и `10`.  
    Отсортированная часть: `[1, 5, 10, 23]`
    
- **Четвёртый проход:**  
    Сравниваем `2` с `1, 5, 10, 23`.  
    Вставляем `2` между `1` и `5`.  
    Отсортированная часть: `[1, 2, 5, 10, 23]`
    
- **Итоговый массив:** `[1, 2, 5, 10, 23]`
    

---

## Анализ сложности сортировки вставками

- **Временная сложность:**
    
    - Лучший случай: `O(n)` — если массив уже отсортирован
        
    - Средний случай: `O(n²)` — если элементы расположены случайным образом
        
    - Худший случай: `O(n²)` — если массив отсортирован в обратном порядке
        
- **Дополнительная память:** `O(1)` — сортировка выполняется на месте, не требует дополнительной памяти
    

---

## Преимущества сортировки вставками

- Простая и лёгкая для реализации
    
- Стабильный алгоритм сортировки (относительный порядок равных элементов сохраняется)
    
- Эффективен для небольших и почти отсортированных массивов
    
- Памяти требуется мало (in-place)
    
- Адаптивен: количество перестановок пропорционально количеству инверсий; для уже отсортированного массива требуется `O(n)` времени
    

---

## Недостатки сортировки вставками

- Неэффективен для больших массивов
    
- В большинстве случаев менее эффективен, чем более сложные алгоритмы (например, Merge Sort или Quick Sort)
    

---

## Применение сортировки вставками

- Массивы небольшого размера или почти отсортированные
    
- Когда важны простота реализации и стабильность
    
- Используется как подрутина в алгоритме **Bucket Sort**
    
- Полезен для почти отсортированных массивов (мало инверсий)
    
- Применяется в гибридных алгоритмах сортировки, таких как **IntroSort** и **TimSort**, где для небольших подмассивов используется сортировка вставками
    
