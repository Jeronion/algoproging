

Стек — это линейная структура данных, которая работает по принципу **LIFO** (_Last In, First Out_ — «последним пришёл, первым вышел») или **FILO** (_First In, Last Out_ — «первым пришёл, последним вышел»). Это означает, что элемент, добавленный последним, извлекается первым.

Представьте стопку тарелок: последняя положенная тарелка будет первой, которую вы снимете.

- **Добавление элемента (push):** как положить новую тарелку сверху.
    
- **Удаление элемента (pop):** как снять верхнюю тарелку.
    

---

## Основные понятия

- **Top (верх):** позиция последнего добавленного элемента. Операции `push` и `pop` выполняются только здесь.
    
- **Size (размер):** текущее количество элементов в стеке.
    

### Типы стеков

1. **Стек фиксированного размера (Fixed Size Stack)**
    
    - Имеет заранее определённую ёмкость.
        
    - При попытке добавить элемент при переполнении возникает **overflow**.
        
    - При удалении из пустого стека возникает **underflow**.
        
    - Реализуется с помощью статического массива.
        
2. **Динамический стек (Dynamic Size Stack)**
    
    - Может автоматически увеличиваться и уменьшаться по мере необходимости.
        
    - Реализуется с помощью:
        
        - **Связного списка** (Linked List) — растёт и сжимается естественно.
            
        - **Динамического массива** (например, `vector` в C++, `ArrayList` в Java, `list` в Python).
            
    - На практике чаще используется динамический стек, так как он не ограничен фиксированной ёмкостью.
        

---

## Основные операции стека

|Операция|Описание|
|---|---|
|`push(x)`|Добавляет элемент `x` на вершину стека.|
|`pop()`|Удаляет верхний элемент и возвращает его.|
|`peek()` / `top()`|Возвращает верхний элемент без удаления.|
|`isEmpty()`|Возвращает `true`, если стек пуст, иначе `false`.|
|`size()`|Возвращает количество элементов в стеке.|
|`isFull()`|Для фиксированного стека: возвращает `true`, если стек полон.|

---

## Применение стека

Стек используется во множестве практических задач:

1. **Функциональные вызовы**
    
    - Стек хранит состояние активных функций.
        
    - Когда функция завершает работу, управление возвращается к вызывающей функции.
        
2. **Рекурсия**
    
    - Для рекурсивных вызовов стек хранит «снимок» каждого вызова с локальными переменными.
        
3. **Вычисление выражений**
    
    - Стек помогает выполнять операции в правильном порядке, особенно для **постфиксной** или **префиксной** нотации.
        
4. **Синтаксический анализ (Parsing)**
    
    - Проверка сбалансированности скобок в коде.
        
5. **Управление памятью**
    
    - Стек — область памяти для локальных переменных, которая быстро выделяется и освобождается по принципу LIFO.
        

---

## Преимущества и недостатки

**Преимущества:**

- Высокая скорость операций `push` и `pop` (O(1)).
    
- Эффективное использование памяти, хранятся только актуальные элементы.
    
- Строгий порядок LIFO полезен в функциях, рекурсии и вычислениях выражений.
    

**Недостатки:**

- Доступ к элементам возможен только сверху.
    
- Возможен **overflow** при фиксированном размере.
    

---

## Реализация стека на массиве (Python)

```python
class Stack:
    def __init__(self, capacity):
        self.capacity = capacity
        self.arr = [0] * capacity
        self.top = -1

    def push(self, x):
        if self.top == self.capacity - 1:
            print("Stack Overflow")
            return
        self.top += 1
        self.arr[self.top] = x

    def pop(self):
        if self.top == -1:
            print("Stack Underflow")
            return -1
        val = self.arr[self.top]
        self.top -= 1
        return val

    def peek(self):
        if self.top == -1:
            print("Stack is Empty")
            return -1
        return self.arr[self.top]

    def isEmpty(self):
        return self.top == -1

    def isFull(self):
        return self.top == self.capacity - 1
```

---

## Динамический стек (на основе списка Python)

```python
class DynamicStack:
    def __init__(self):
        self.arr = []

    def push(self, x):
        self.arr.append(x)

    def pop(self):
        if not self.arr:
            print("Stack Underflow")
            return -1
        return self.arr.pop()

    def peek(self):
        if not self.arr:
            print("Stack is Empty")
            return -1
        return self.arr[-1]

    def isEmpty(self):
        return len(self.arr) == 0

    def size(self):
        return len(self.arr)
```

---

## Сравнение: фиксированный стек vs динамический

|Свойство|Фиксированный стек|Динамический стек|
|---|---|---|
|Ёмкость|Фиксированная|Растёт автоматически|
|Overflow|Возможен|Нет (пока есть память)|
|Простота|Простая реализация|Чуть сложнее из-за управления памятью|
|Эффективность|Быстрее (меньше аллокаций)|Немного медленнее при расширении|

---

Если хочешь, я могу сделать **наглядную схему работы стека с push и pop**, чтобы визуально показать, как элементы добавляются и удаляются. Это сильно помогает для понимания.

Хочешь, чтобы я её сделал?