# Структура данных «Связный список»

Связный список — это фундаментальная структура данных в информатике. Он обеспечивает более эффективные операции вставки и удаления по сравнению с массивами. Как и массивы, связные списки используются для реализации других структур данных, таких как стек, очередь и дек.

Связный список — это линейная структура данных, элементы которой не обязательно расположены в непрерывных областях памяти. Отдельные элементы называются узлами (nodes) и соединяются друг с другом с помощью ссылок.

Связный список используется в реализации структур данных:
- [[Стек]]
- Дек
- Очередь

- Узел содержит две части:
    1. данные
    2. ссылку на следующий узел

- Первый узел называется **головой (head)**. Используя head и ссылки next, можно пройти по всему списку.

## Сравнение связного списка и массива

### Связный список:

- **Структура данных:** Непрерывность отсутствует (non-contiguous)
- **Выделение памяти:** Обычно выделяется отдельно для каждого элемента
- **Вставка/Удаление:** Эффективные
- **Доступ:** Последовательный

### Массив:

- **Структура данных:** Непрерывная (contiguous)
- **Выделение памяти:** Выделяется сразу для всего массива
- **Вставка/Удаление:** Неэффективные
- **Доступ:** Произвольный (random access)

---

# Односвязный список (Singly Linked List)

Односвязный список — это базовая структура данных, состоящая из узлов, где каждый узел содержит поле данных и ссылку на следующий узел. Поле next последнего узла равно `null`, что означает конец списка.

Связные списки поддерживают эффективные операции вставки и удаления.

## Структура узла

В односвязном списке каждый узел состоит из:

- данных (data)
- указателя на следующий узел (next)

Пример определения узла:

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
```

---

## Создание примера связного списка из 3 элементов

### Создание первого узла

- Выделить память
- Сохранить данные
- Обозначить его как head

### Создание второго узла

- Выделить память
- Сохранить данные
- Связать первый узел с новым (`head.next`)

### Создание третьего узла

- Выделить память
- Сохранить данные
- Связать второй узел с третьим
- Установить `next = None`

Пример:

```python
class Node:
    def __init__(self, new_data):
        self.data = new_data
        self.next = None

head = Node(10)
head.next = Node(20)
head.next.next = Node(30)
head.next.next.next = Node(40)

temp = head
while temp is not None:
    print(temp.data, end=" ")
    temp = temp.next
```

**Вывод:**

```
10 20 30 40
```

---

## Основные операции в связном списке

- **Обход (Traversal)** — прохождение по списку
- **Вставка (Insertion)** — в начало, в конец, в конкретную позицию
- **Удаление (Deletion)** — из начала, из конца, из конкретной позиции
- **Поиск (Searching)** — проверка существования элемента
- **Обновление (Updating)** — изменение значения узла
- **Разворот (Reversal)** — сделать последний узел новой головой

---

## Применение связных списков

### Преимущества

- Динамический размер
- Эффективная вставка и удаление в начале и конце
- Возможность реализации сложных структур (стек, очередь, граф)

### Недостатки

- Дополнительная память для хранения указателей
- Нет прямого (произвольного) доступа
- Низкая кэш-эффективность

---

# Двусвязный список (Doubly Linked List)

Двусвязный список — более сложная структура данных по сравнению с односвязным списком, но предоставляет дополнительные возможности.

Главное преимущество — возможность перемещения в обе стороны.

## Представление двусвязного списка

Каждый узел содержит:

- данные (data)
- указатель на следующий узел (next)
- указатель на предыдущий узел (prev)

Пример определения узла:

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None
```

---

## Создание двусвязного списка из 4 узлов

```python
class Node:
    def __init__(self, value):
        self.data = value
        self.prev = None
        self.next = None

head = Node(10)

head.next = Node(20)
head.next.prev = head

head.next.next = Node(30)
head.next.next.prev = head.next

head.next.next.next = Node(40)
head.next.next.next.prev = head.next.next

temp = head
while temp is not None:
    print(temp.data, end="")
    if temp.next is not None:
        print(" <-> ", end="")
    temp = temp.next
```

**Вывод:**

```
10 <-> 20 <-> 30 <-> 40
```

---

## Основные операции

- Обход
- Вставка (в начало, конец, позицию)
- Удаление (из начала, конца, позиции)

---

## Преимущества двусвязного списка

- Двунаправленный обход
- Удаление за O(1), если есть указатель на узел
- Эффективная вставка в начало и конец
- Удобен для реализации deque, undo/redo, истории браузера

### Недостатки

- Дополнительная память (указатель prev)
- Более сложная реализация
- Небольшие накладные расходы
- Низкая кэш-эффективность

---

# Кольцевой связный список (Circular Linked List)

Кольцевой связный список — это структура данных, в которой последний узел указывает обратно на первый, образуя замкнутый круг.

## Особенности

- Нет `None`
- Можно выполнять непрерывный обход
- Отличается от обычного списка тем, что последний узел указывает на первый

## Типы кольцевых списков

### 1. Кольцевой односвязный список

- Каждый узел имеет один указатель `next`
- Последний узел указывает на первый
- Движение только в одном направлении

### 2. Кольцевой двусвязный список

- Каждый узел имеет `next` и `prev`
- Последний указывает на первый
- Первый указывает на последний

---

## Почему используют указатель на последний узел?

Если хранить указатель на последний узел:

- Вставка в начало — $O(1)$
- Вставка в конец — $O(1)$
- Не нужно проходить весь список

---

## Преимущества кольцевого списка

- Эффективный обход
- Нет None-указателей
- Подходит для повторяющихся задач (плейлисты, планирование)
- Вставка в начало/конец — $O(1)$
- Равномерный обход
- Эффективное использование памяти

### Недостатки

- Более сложная реализация
- Риск бесконечного цикла
- Сложнее отладка
- Сложность удаления
- Дополнительная память (для двусвязного)
- Низкая кэш-эффективность